# 使用AXUM构建短链接服务

使用[axum](https://github.com/tokio-rs/axum)构建高性能的短链服务，实现把长链接转化成长度固定的短链接。

## 短链原理
通过[雪花算法](https://gitee.com/yitter/idgenerator)给每个链接生成一个唯一id,然后把生成的id转成62进制字符串以达到压缩字符串长度的目的,同时储存这次结果。当请求访问时通过62进制转10进制得到id，通过ID找到原始地址，最后重定向到该地址。

 - 持久化和缓存
 在整个过程中会使用PostgreSQL来保存链接数据，使用redis缓存数据以提高性能
 - 防止相同地址多次生成
 相同的地址是不需要重复生成短链，因此会对源地址进行sha256计算得到43位的哈希码，通过对比这个哈希码来判断是否已有重复的数据。选择sha256目的也只是降低hash碰撞的概率，当然可以考虑性能更好的算法。
 - 定时清理过期链接
 应用启动时会自动启动一个后台定时任务，每小时执行一次，自动清理数据库中已过期的链接（将active字段标记为false）并同步清除Redis缓存中的相关数据，保持数据的一致性和系统的健康运行。

## 技术栈
- **Rust** 1.91.0 (2024 Edition)
- **AXUM** 0.7.x - 高性能异步Web框架
- **PostgreSQL** - 主数据库
- **Redis** - 缓存系统
- **SQLx** 0.8.x - 异步数据库ORM
- **bb8** - 连接池管理
- **Serde** - 序列化/反序列化
- **Tracing** - 结构化日志记录
- **UUID** - 唯一标识符生成

## 运行项目

### 直接启动
本项目会使用到PostgreSQL和Redis，所以在启动前请确保这两个服务已经正确安装。

1. **数据库初始化**：目前需要手动创建表，DDL语句可以在 `./sql/ddl.sql`中查看
2. **配置修改**：根据实际情况修改项目配置 `./application.yaml`
3. **启动应用**：
```shell
cargo run
```

### Docker运行
```shell
# 构建镜像
docker build -t short-link:latest -f ./Dockerfile --no-cache .

# 运行镜像
docker run -d  \
  --name short-link \
  --link postgres \
  --link redis \
  -u root \
  -e DATABASE_URL=postgresql://postgres:123456@postgres:5432/short_link \
  -e REDIS_URL=redis://redis:6379 \
  -p 8008:8008 \
  -v "$PWD/application.yaml":/usr/app/application.yaml \
  -v "$PWD/logs":/usr/app/logs \
  short-link:latest
```

**注意事项**：
- `--link postgres` 和 `--link redis` 根据实际情况调整
- Docker 接收 `DATABASE_URL` 和 `REDIS_URL` 环境变量来指定连接地址
- 环境变量的优先级高于配置文件

## API文档

### 公共API
- `GET /s/{hash}` - 重定向到原始URL

### 管理API
- `POST /link/create` - 创建短链接
  ```json
  {
    "url": "https://example.com",
    "duration": 3600
  }
  ```
- `GET /link/list` - 获取链接列表（支持分页）
  ```bash
  GET /link/list?page=1&page_size=10
  ```

## 主要特性

- ✅ **高性能**：基于Rust和AXUM异步框架，支持高并发 
- ✅ **智能缓存**：Redis双层缓存策略（hash->ID, ID->URL） 
- ✅ **防重复生成**：SHA256哈希检测相同URL 
- ✅ **结构化日志**：详细的请求/响应日志，支持JSON格式化输出 
- ✅ **优雅关闭**：支持信号处理和资源清理 
- ✅ **CORS支持**：跨域请求支持 
- ✅ **分页查询**：链接列表支持高效分页

## 性能测试

基于 **Docker 部署**（ARM64 架构，10 核心）的性能测试结果：

### 创建短链接 API (`POST /link/create`)

#### 常规负载测试
- **低并发测试**：1000 请求，10 并发
  - **吞吐量**：889.42 请求/秒
  - **平均响应时间**：11.24ms
  - **P95 响应时间**：22ms
  - **成功率**：100%

- **高并发测试**：2000 请求，100 并发
  - **吞吐量**：1,295.36 请求/秒
  - **平均响应时间**：77.20ms
  - **P95 响应时间**：238ms
  - **成功率**：100%

#### 极限压力测试
- **超高并发测试**：5000 请求，200 并发
  - **吞吐量**：1,924.65 请求/秒
  - **平均响应时间**：103.91ms
  - **P95 响应时间**：374ms
  - **成功率**：100%

- **突发流量测试**：3000 请求，500 并发
  - **吞吐量**：1,828.38 请求/秒
  - **平均响应时间**：273.47ms
  - **P95 响应时间**：802ms
  - **成功率**：100%

#### 长时间稳定性测试
- **持续负载测试**：20,000 请求，50 并发（运行时间 11.88 秒）
  - **吞吐量**：1,683.62 请求/秒
  - **平均响应时间**：29.70ms
  - **P95 响应时间**：74ms
  - **成功率**：100%
  - **稳定性**：长时间运行无性能衰减

### 短链接访问 API (`GET /s/{hash}`)
- **高并发重定向测试**：5000 请求，50 并发
  - **吞吐量**：2,322.02 请求/秒
  - **平均响应时间**：21.53ms
  - **P95 响应时间**：50ms
  - **成功率**：100%

- **极限重定向测试**：10,000 请求，300 并发
  - **吞吐量**：2,348.28 请求/秒
  - **平均响应时间**：127.75ms
  - **P95 响应时间**：405ms
  - **成功率**：100%

### 管理查询 API (`GET /link/list`)
- **分页查询测试**：2000 请求，100 并发
  - **吞吐量**：1,726.80 请求/秒
  - **平均响应时间**：57.91ms
  - **P95 响应时间**：65ms
  - **成功率**：100%

### 资源使用情况
- **内存占用**：3-4 MiB（轻量级运行）
- **CPU 使用率**：< 0.1%（空闲时），峰值使用率很低
- **网络 I/O**：高效处理重定向和API请求
- **连接处理**：支持 500+ 并发连接

### QPS（每秒查询数）极限测试

#### 创建短链接 QPS 上限
- **最佳QPS**：1,845 请求/秒（250并发）
- **高负载QPS**：1,784 请求/秒（400并发）
- **QPS峰值**：1,924 请求/秒（200并发）
- **推荐负载**：1,600-1,800 QPS（稳定区间）

#### 重定向访问 QPS 上限
- **极限QPS**：3,236 请求/秒（400并发，15000请求）
- **高负载QPS**：3,080 请求/秒（600并发，20000请求）
- **QPS峰值**：2,348 请求/秒（300并发）
- **推荐负载**：2,500-3,000 QPS（稳定区间）

#### 查询链接 QPS 上限
- **最佳QPS**：1,747 请求/秒（500并发，8000请求）
- **稳定QPS**：1,734 请求/秒（300并发，5000请求）
- **推荐负载**：1,600-1,700 QPS（稳定区间）

### 性能优势
- 🚀 **超高QPS**：创建链接 1,800+ QPS，重定向 3,200+ QPS，查询 1,700+ QPS
- ⚡ **低延迟**：平均响应时间 < 100ms，P95 < 400ms
- 💾 **资源高效**：内存占用 < 5MB，CPU 使用率极低
- 🔄 **超高并发**：支持 600+ 并发连接，突发流量处理能力强
- 📈 **稳定性**：所有测试场景 100% 成功率，长时间运行稳定
- 🎯 **读优化**：重定向性能极佳，QPS是写操作的1.8倍
- 📊 **负载均衡**：各API性能均衡，无显著瓶颈

## 开发工具

### 常用命令
```bash
# 运行项目
cargo run

# 构建发布版本
cargo build --release

# 类型检查
cargo check

# 代码格式化
cargo fmt

# 运行测试
cargo test
```

### 日志记录
- **控制台日志**：彩色美化格式，便于开发调试
- **文件日志**：按天滚动，存储在 `./logs/` 目录
- **请求跟踪**：每个请求都有唯一ID，支持完整的请求-响应链路跟踪
- **JSON格式化**：自动识别并格式化JSON响应，便于复制使用

## 项目结构
```
src/
├── main.rs              # 程序入口，中间件配置
├── config.rs            # 配置管理
├── prepare.rs           # 状态初始化，数据库连接
├── handle/              # HTTP处理器
│   ├── admin.rs         # 管理API
│   └── api.rs           # 公共API
├── service/             # 业务逻辑层
│   ├── link_service.rs  # 链接服务
│   ├── link_base_service.rs # 数据访问层
│   └── cleanup_service.rs   # 定时清理服务
├── pojo/                # 数据模型
├── idgen/               # ID生成器
├── utils/               # 工具函数
└── types.rs             # 类型定义
```

## 未来计划
- [x] ✅ 请求拦截器，对请求参数和响应进行日志打印
- [x] ✅ 定时任务，定期清除过期的链接数据
- [ ] 📋 管理界面，用于配置和统计
- [ ] 📋 链接访问统计和分析
- [ ] 📋 批量生成短链接功能
